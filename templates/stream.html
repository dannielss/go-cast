<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LiveStream App - Broadcaster</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-100 text-gray-900">
    <header class="p-4">
      <h1 class="text-xl font-bold text-center">You're Live!</h1>
    </header>

    <main class="flex flex-col items-center gap-4">
      <video
        id="local"
        autoplay
        muted
        playsinline
        class="w-full max-w-2xl border shadow-md"
      ></video>
      <p id="errorMsg" class="text-red-600 text-center"></p>
    </main>

    <script>
      const ws = new WebSocket(
        `ws://${location.host}/ws/signal?role=broadcaster&stream=test`
      );
      const video = document.getElementById("local");
      const errorMsg = document.getElementById("errorMsg");

      let localStream = null;
      const peerConnections = {}; // viewerId => RTCPeerConnection
      const pendingViewers = [];

      async function initMedia() {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          video.srcObject = localStream;

          const audioTracks = localStream.getAudioTracks();
          if (audioTracks.length === 0) {
            errorMsg.textContent = "Warning: No audio track detected.";
          }

          // Handle any viewers who joined before media was ready
          for (const viewerId of pendingViewers) {
            await handleViewerJoin(viewerId);
          }
          pendingViewers.length = 0;
        } catch (err) {
          console.error("Media error:", err);
          errorMsg.textContent =
            "Unable to access camera/mic. Check permissions.";
        }
      }

      function createPeerConnection(viewerId) {
        const pc = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });

        // Add tracks safely
        if (localStream) {
          localStream.getTracks().forEach((track) => {
            try {
              pc.addTrack(track, localStream);
            } catch (err) {
              console.warn("Track already added or error:", err);
            }
          });
        }

        // ICE candidate handling
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            ws.send(
              JSON.stringify({
                type: "candidate",
                candidate: event.candidate,
                id: viewerId,
              })
            );
          }
        };

        pc.oniceconnectionstatechange = () => {
          console.log(`ICE (${viewerId}): ${pc.iceConnectionState}`);
        };

        pc.onconnectionstatechange = () => {
          console.log(`Connection (${viewerId}): ${pc.connectionState}`);
          if (
            ["failed", "disconnected", "closed"].includes(pc.connectionState)
          ) {
            delete peerConnections[viewerId];
            console.log(`Removed connection for ${viewerId}`);
          }
        };

        peerConnections[viewerId] = pc;
        return pc;
      }

      async function handleViewerJoin(viewerId) {
        const pc = createPeerConnection(viewerId);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(
          JSON.stringify({ type: "offer", sdp: offer.sdp, id: viewerId })
        );
        console.log(`Offer sent to viewer ${viewerId}`);
      }

      ws.onopen = () => {
        console.log("WebSocket connected (broadcaster)");
      };

      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        const viewerId = msg.id;
        if (!viewerId) return;

        switch (msg.type) {
          case "viewer-joined":
            if (!peerConnections[viewerId]) {
              if (!localStream) {
                pendingViewers.push(viewerId);
              } else {
                await handleViewerJoin(viewerId);
              }
            } else {
              console.log(`Viewer ${viewerId} already has a connection`);
            }
            break;

          case "answer":
            const pc = peerConnections[viewerId];
            if (pc && pc.signalingState === "have-local-offer") {
              await pc.setRemoteDescription(new RTCSessionDescription(msg));
              console.log(`Remote description set for ${viewerId}`);
            }
            break;

          case "candidate":
            const peer = peerConnections[viewerId];
            if (peer) {
              try {
                await peer.addIceCandidate(new RTCIceCandidate(msg.candidate));
                console.log(`ICE candidate added from ${viewerId}`);
              } catch (err) {
                console.error("Error adding ICE candidate:", err);
              }
            }
            break;
        }
      };

      ws.onerror = (err) => console.error("WebSocket error:", err);
      ws.onclose = () => console.log("WebSocket closed");

      initMedia();
    </script>
  </body>
</html>
